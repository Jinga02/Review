<img src="https://user-images.githubusercontent.com/110621233/231062359-1b7d42fd-45a2-4605-8034-c342d05d5a9d.png"></img>
> <!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
    <h2>함수</h2>
      <ul>
          <li>참조 타입 중 하나로써 function타입에 속한다.</li>
          <li>함수 선언식과 함수표현식 2가지로 구분된다.</li>
          <li>기본 인자(Default arguments)</li>
          <ul>
            <li>인자 작성시 '=' 문자 뒤 기본 인자 선언이 가능하다.</li>
            <li>매개변수와 인자의 개수 불일치를 허용한다.</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965790-4cc07a2d-c42f-4301-858b-a24ad3b228a6.png" alt="인자의개수 불일치 허용">
          </ul>
          <li>Spread syntax(...)/ 전개구문</li>
          <ul>
            <li>전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 <br>
                배열의 경우는 요소, 함수의 경우는 인자로 확장할 수 있다.</li>
            <li>배열과의 사용(배열 복사)</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965788-5a96564e-eab9-4771-8ae0-318c8e01d029.png" alt="배열과의 사용">
            <li>함수와의 사용(Rest parameters) - 정해지지 않은 수의 매개변수를 배열로 받을 수 있다</li>
            <img src="https://user-images.githubusercontent.com/110621233/232972484-ced413ab-8303-487b-ba0d-2b04ce6b72aa.png" alt="함소와의 사용">
          </ul>
      </ul>
    <h2>선언식과 표현식</h2>
      <ul>
          <li>함수의 타입</li>
          <img src="https://user-images.githubusercontent.com/110621233/232965785-524acdf6-a73f-4a6a-b4bf-ab4986161b80.png" alt="함수 선언식과 표현식">
          <li>호이스팅- 선언식</li>
          <ul>
            <li>함수 선언식으로 정의한 함수는 var로 정의한 변수처럼 호이스팅이 발생한다.</li>
            <li>즉, 함수 호출 이후에 선언해도 동작한다.</li>
          </ul>
          <li>호이스팅 - 표현식</li>
          <ul>
            <li>함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러가 발생한다.</li>
            <li>함수 표현식으로 정의된 함수는 변수로 평가되어 변수의 scope규칙을 따른다.</li>
            <li>선언식보다는 표현식을 사용하는걸 권장한다.</li>
          </ul>
                    <li></li>
      </ul>
    <h2>Arros Fucntion</h2>
    <ul>
        <li>=>를 이용해 함수를 비교적 간결하게 정의할 수 있는 문법이다.</li>
        <li>규칙</li>
        <ul>
        <li>function 키워드 생략이 가능하다.</li>
        <li>함수의 매개변수가 하나 뿐이라면 매개변수의 '()" 생략이 가능하다.</li>
        <li>함수의 내용이 한 줄이라면 '{}'와 'return'도 생략이 가능하다.</li>
        <li>화살표 함수는 항상 익명함수이므로, 함수 표현식에서만 사용이 가능하다.</li>
        </ul>
        <img src="https://user-images.githubusercontent.com/110621233/232965782-dd95ede1-63e4-428a-be69-8b6c42ef0554.png" alt="화살표 함수 예시">
        <img src="https://user-images.githubusercontent.com/110621233/232965780-e152dea2-585f-4dc3-9620-59cc75c242ac.png" alt="화살표 함수 응용  ">
    </ul>
  
> <h2>this</h2>
      <ul>
        <li>어떠한 object를 가리키는 키워드 이다.</li>
        <li>함수는 호출될 때 this를 암묵적으로 전달 받는다.</li>
        <li>해당 함수 호출 방식에 따라 this에 바인딩 되는 객체가 달라진다.</li>
        <li>함수를 선언할 떄 this에 객체가 결정되는 것이 아니고, <br>
            함수를 호출할 때 함수가 어떻게 호출 되었는지에 따라 동적으로 결정된다.</li>
        <h3><li>전역 문맥에서의 this</li></h3>
        <ul>
            <li>브라우저의 전역 객체인 window를 가리킨다.</li>
            <li>전역객체는 모든 객체의 유일한 최상위 객체를 의미한다.</li>
            <li>console.log(this) // window</li>
        </ul>
        <h3><li>함수 문맥에서의 this</li></h3>
        <ul>
            <li>함수 내부에서 this의 값은 함수를 호출한 방법에 의해 좌우된다.</li>
            <h4><li>단순 호출</li></h4>
            <ul>
                <li>전역객체를 가리키며, 브라우저에서 전역은 window를 의미한다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232967312-3015aca8-a55c-42b6-a33e-95f117cac63b.png" alt="this_단순호출">
            </ul>
            <h4><li>Method(function in objecs, 객체의 메서드로서</li></h4>
            <ul>
                <li>메서드로 선언하고 호출한다면, 객체의 메서드이므로 해당 객체가 바인딩</li>
                <img src="https://user-images.githubusercontent.com/110621233/232967307-c2946a58-ffc0-429c-a634-925ca61f4b34.png" alt="this_메서드">
            </ul>
            <h4><li>Nested</li></h4>
            <ol>
                <li>Function키워드</li>
                <ul>
                    <li>forEach의 콜백함수에서의 this가 메서드의 객체를 가리키지 못하고 전역 객체 window를 가리킨다.</li>
                    <li>단순호출방식으로 사용되었기 때문이다.</li>
                    <li>이를 해결하기 위해 등장한 함수 표현식이 바로 '화살표 함수'이다.</li>
                    <img src="https://user-images.githubusercontent.com/110621233/232965777-cf93897f-e448-492a-bb99-3e37fa1e0de0.png" alt="Nested_function키워드">
                </ul>
                <li>화살표 함수</li>
                <ul>
                    <li>일반 function 키워드와 달리 메서드의 객체를 잘 가리킨다.</li>
                    <li>화살표 함수에서 this는 자신을 감싼 정적 범위</li>
                    <li>자동으로 한 단계 상위의 scope의 context를 바인딩</li>
                    <img src="https://user-images.githubusercontent.com/110621233/232965776-8dd664ae-996b-44d2-9db6-5b832ac50c67.png" alt="Nested_화살표함수">
                    <li>화살표 함수는 호출의 위치와 상관없이 상위 스코프를 가리킨다.(Lexical scope this)</li>
                    <li>Lexical scope</li>
                    <ul>
                        <li>함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정</li>
                        <li>Static scpoe라고도 하며, 대부분의 프로그래밍 언어에서 따르는 방식이다.</li>
                        <li>함수 내의 함수에서도 화살표 함수를 사용하는것을 권장한다.</li>
                        <img src="https://user-images.githubusercontent.com/110621233/232965775-d37becce-188d-42b5-8037-e8626fbbe026.png" alt="Lexical scope">
                    </ul>
                </ul>
            </ol>
            <li>함수(Method)를 하나만 만들어 여러 객체에서 재사용할 수 있다는 것은 장점이지만, <br>
                이런 유연함이 실수로 이어질 수 있다는 단점도 가지고 있다.</li>                
        </ul>
      </ul>
  
  >  <h2>Array</h2>
    <ul>
        <li>키와 속성들을 담고 있는 참조 타입의 객체</li>
        <li>순서를 보장하는 특징을 가지고 있다.</li>
        <li>주로 대괄호 '[]'를 이용하여 생성하고, 0을 포함한 양의 정수 인덱스로 특정 값에 접근이 가능하다.</li>
        <h3><li>Array 메서드 기초</li></h3>
        <ul>
            <li>reverse - 원본 배열의 요소들의 순서를 반대로 정렬해준다.</li>
            <li>push & pop - 배열의 가장 뒤에 요소를 추가 또는 제거한다.</li>
            <li>unshift & shift - 배열의 가장 앞에 요소를 추가 또는 제거한다.</li>
            <li>includes - 배열에 특정 값이 존재하는 판별 후 참/거짓을 반환한다.</li>
            <li>indexOf - 배열에 특정 값이 존재하는지 판별 후 인덱스를 반환하다.(요소가 없을 경우 -1반환)</li>
        </ul>
        <h3><li>Array 메서드 심화</li></h3>
        <ul>
            <li>배열을 순회하면 특정 로직을 수행하는 메서드로, 메서드 호출 시 인자로 callback함수를 받는것이 특징이다.</li>
            <li>callback함수란 어떤 함수의 내부에서 실행될 목적으로 인자로 넘겨받는 함수이다.</li>
            <h4><li>forEach - 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행한다.(반환 값은 없다.)</li></h4>
            <ul>
                <li>array.forEach(callback(element[, index[,array]]))</li>
                <li>인자로 주어지는 함수(콜백 함수)를 배열의 각 요소에 대해 한 번씩 실행한다.</li>
                <li>element : 배열의 요소, index : 배열 요소의 인덱스, array : 배열 자체</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965770-2b2331ab-7b07-4451-8999-9348da46b9ca.png" alt="forEach1">
                <img src="https://user-images.githubusercontent.com/110621233/232965820-386d128b-3af8-48f3-bbbf-ce1da5e2c54c.png" alt="forEach2">
            </ul>
            <h4><li>map - 콜백 함수의 반환 값을 요소로 하는 새로운 배열을 반환한다.</li></h4>
            <ul>
                <li>array.map(callback(element[, index[, array]]))</li>
                <li>배열의 각 요소에 대해 콜백 함수를 한 번씩 실행</li>
                <li>콜백 함수의 반환 값을 요소로 하는 새로운 배열을 반환한다.</li>
                <li>기존 배열 전체를 다른 형태로 바꿀 떄 유용하다.</li>
                <li>forEach + return</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965818-a7b2b36b-9d8c-45e2-9170-997bd826d866.png" alt="map">
            </ul>
            <h4><li>filter - 콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열을 반환한다.</li></h4>
            <ul>
                <li>array.filter(callback(element[, index[, array]]))</li>
                <li>배열의 각 요소에 대해 콜백 함수를 한 번씩 실행한다.</li>
                <li>콜백 함수의 반환 값이 true인 요소들만 모아서 새로운 배열을 반환한다.</li>
                <li>기존 배열의 요소들을 필터링할 때 유요하다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965816-27de52d3-4da1-41bc-a3dc-f68665bc0371.png" alt="filter">
            </ul>
            <h4><li>reduce - 콜백 함수의 반환 값들을 하나의 값(acc)에 누적 후 반환한다.</li></h4>
            <ul>
                <li>array.reduce(callback(acc, element, [index[, array]])[, initialValue])</li>
                <li>인자로 주어지는 함수(콜백 함수)를 배열의 각 요소에 대해 한 번씩 실행해서, 하나의 결과 값을 반환한다.</li>
                <li>배열을 하나의 값으로 계산하는 동작이 필요할 떄 사용한다(총합, 평균 등)</li>
                <li>map, filter 등 여러 배열 메서드 동작을 대부분 대체할 수 있다.</li>
                <li>acc - 이전 callback함수의 반환 값이 누적되는 변수</li>
                <li>initialValue(optional) - 최초 callback 함수 호출 시 acc에 할당되는 값, default 값은 배열의 첫 번째 값 <br>
                    빈 배열의 경우 initialValue를 제공하지 않으면 에러가 발생한다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965813-25057745-2801-48a3-b1b3-ee37e580b709.png" alt="reduce">
            </ul>
            <h4><li>find - 콜백 함수의 반환 값이 참이면 해당 요소를 반환한다.</li></h4>
            <ul>
                <li>array.find(callback(element[, index[, array]]))</li>
                <li>배열의 각 요소에 대해 콜백 함수를 한 번씩 실행한다.</li>
                <li>콜백 함수의 반환 값이 true면, 조건을 만족하는 첫번째 요소를 반환한다.</li>
                <li>찾는 값이 배열에 없으면 undefined를 반환한다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965811-69cf8d99-c326-4e5f-94c5-d2a3e65868fb.png" alt="find">
            </ul>
            <h4><li>some - 배열의 요소 중 하나라도 판별 함수를 통과하면 참을 반환한다.</li></h4>
            <ul>
                <li>array.some(callback(element[, index[, array]]))</li>
                <li>배열의 요소 중 하나라도 주어진 판별 함수를 통과하면 true를 반환한다.</li>
                <li>모든 요소가 통과하지 못하면 거짓을 반환한다.</li>
                <li>빈 배열은 항상 false를 반환한다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965808-7367ea41-99ce-4bd9-8fad-9178343c1450.png" alt="some">
            </ul>
            <h4><li>every - 배열의 모든 요소가 판별 함수를 통과하면 참을 반환한다.</li></h4>
            <ul>
                <li>array.every(callback(element[, index[, array]]))</li>
                <li>배열의 모든 요소가 주어진 판별 함수를 통과하면 true를 반환한다.</li>
                <li>하나의 요소라도 통과하지 못하면 false를 반환한다.</li>
                <li>빈 배열은 항상 true를 반환한다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965807-231b19ac-f793-4742-ad6d-37f23be04011.png" alt="every">
            </ul>
        </ul>
        <h3><li>Callback Fucntion(콜백 함수)</li></h3>
        <ul>
            <li>다른 함수의 인자로 전달되는 함수를 뜻한다.</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965774-96e72402-3723-4ca2-8950-a8ddc91d5650.png" alt="콜백함수 예시1">
        </ul>
    
   ><h2>객체(Object)</h2>
    <ul>
        <li>객체는 속성(property)의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현한다.</li>
        <h4><li>key</li></h4>
        <ul>
            <li>문자열 타입만 가능하다.</li>
            <li>key이름에 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 표현한다.</li>
        </ul>
        <h4><li>value</li></h4>
        <ul>
            <li>모든 타입(함수포함)이 가능하다.</li>
        </ul>
        <h4><li>객체 요소 접근</li></h4>
        <ul>
            <li>점(.) 또는 대괄호[]로 가능하다.</li>
            <li>key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호가 접근만 가능하다.</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965803-ab3b3616-8c84-48b1-b5ae-4d9d265fd1d2.png" alt="객체예시">
        </ul>
        <h4><li>생성자 함수</li></h4>
        <ul>
            <li>동일한 구조의 객체를 여러개 만들 때 사용한다.</li>
            <li>new연산자로 사용하는 함수</li>
            <li>함수 이름은 반드시 대문자로 시작해야한다.</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965802-7b38a3c3-ee8f-4625-80ae-9a659bf7130c.png" alt="생성자 함수">
        </ul>
        <h4><li>객체 관련 문법</li></h4>
        <ol>
            <li>속성명 축약</li>
            <ul>
                <li>객체를 정의할 때 key와 할당하는 변수의 이름이 같으면 예시와 같이 축약이 가능하다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965801-0e391830-b37a-4cf5-a487-c47384c8a4cc.png" alt="속성명 축약">
            </ul>
            <li>메서드명 축약</li>
            <ul>
                <li>메서드 선언 시 function 키워드 생략이 가능하다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965800-36685187-8971-40a1-a85e-ff412ad5eb61.png" alt="메서드명 축약">
            </ul>
            <li>계산된 속성</li>
            <ul>
                <li>객체를 정의할 떄 key의 이름을 표현식을 이용하여 동적으로 생성 가능하다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965797-94c154d0-f1cf-4642-8ea2-ce96228e019d.png" alt="계산된 속성">
            </ul>
            <li>구조 분해 할당</li>
            <ul>
                <li>배열 또는 객체를 분해하여 속성을 변수에 쉽게 할당할 수 있는 문법이다.</li>
                <img src="https://user-images.githubusercontent.com/110621233/232965794-41863e89-5978-4e65-a222-09c39c44a5ec.png" alt="구조 분해 할당">
            </ul>
            <li>Spread syntax(...)</li>
            <ul>
                <li>배열과 마찬가지로 전개구문을 사용해 객체 내부에서 객체 전개가 가능하다.</li>
                <li>얕은 복사에 활용이 가능하다.</li>
            </ul>
            <li>JSON</li>
            <li>Key - Value 형태로 이루어진 데이터오브젝트를 전달하기 위해, 인간이 읽을 수 있는 텍스트 형식의 개방형 데이터 포멧이다.</li>
            <li>JavaScript의 Object의 유사한 구조를 가지고 있지만 Object는 그 자체로 타입이고, JSON은 형식이 있는 문자열이다.</li>
            <li>JSON을 Object로 사용하기 위해서는 변환 작업이 필요하다.</li>
            <img src="https://user-images.githubusercontent.com/110621233/232965792-9d9e9b68-725a-4b14-8204-7723187832a5.png" alt="JSON">
        </ol>
    </ul>
    </ul>
    
   > <h3>참고</h3>
    <h3>this <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this">MDN</a></h3>
    <h3>this <a href="https://poiemaweb.com/js-this">poiemaweb</a></h3>
    
  <img src="https://user-images.githubusercontent.com/110621233/231062359-1b7d42fd-45a2-4605-8034-c342d05d5a9d.png"></img>
</body>
</html>